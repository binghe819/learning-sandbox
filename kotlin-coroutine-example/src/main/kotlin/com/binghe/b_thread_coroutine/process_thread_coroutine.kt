package com.binghe.b_thread_coroutine

/**
 * 프로세스 (process)는 컴퓨터에서 실행되고 있는 프로그램을 의미한다.
 *
 * 스레드 (thread)는 프로세스보다 작은 개념으로 프로세스에 소속되어 여러 코드를 동시에 실행할 수 있도록해준다.
 * 스레드는 코드를 실행하고 따라서 우리가 작성한 코드는 특정 스레드에서 실행된다. 만약 한 프로세스가 여러 개의 스레드를 갖고 있다면 멀티스레드 환경이라고 한다.
 *
 * 코루틴은 스레드보다 작은 개념이다. 하지만 프로세스-스레드와 스레드-코루틴을 비유하기엔 스레드와 코루틴에 차이가 꽤나 존재한다.
 * - 코루틴은 단지 우리가 작성한 루틴, 코드의 종류중 하나이기 때문에 코루틴 코드가 실행되려면 스레드가 있어야한다.
 * - 코루틴은 중단되었다가 재개될 수 있기 때문에, 코루틴 코드의 앞부분은 1번 스레드에 배정되고, 뒷부분은 2번 스레드에 배정될 수 있다. (실행 스레드가 변경될 수 있다.)
 *   - 한 스레드는 오직 한 프로세스에만 포함될 수 있다. 반면 코루틴의 코드는 여러 스레드에서 실행될 수 있다.
 * - 가장 큰 차이점은 컨텍스트 스위칭에 차이가 존재한다.
 *   - 프로세스가 각각 독립된 메모리 영역을 갖고 있기 때문에 1번 프로세스 -> 2번 프로세스로 스위칭이 발생하면 힙 영역과 스탭 영역 모두 교체되어야한다. (컨텍스트 스위칭 비용이 제일 크다)
 *   - 스레드는 독립된 스택 영역을 갖고 있지만, 힙 영역을 공유하기 때문에 실행이 변경되면 스택 영역만 스위칭한다. (프로세스보단 스위칭 비용이 적다)
 *   - 코루틴은 동일한 스레드에서 코루틴이 실행되면, 메모리 전부를 공유하므로 스레드보다는 컨텍스트 스위칭 비용이 적다.
 * - 동시성 확보 측면에서 스레드는 여러 개의 스레드가 필요하지만, 코루틴은 하나의 스레드에서 여러 개가 번갈아 실행될 수 있기에 하나의 스레드만으로도 동시성을 확보할 수 있다.
 * - 코루틴은 JVM (애플리케이션)상에서의 동작으므로 `yield`를 호출하면 다른 코루틴에게 자리를 양보한다. 반면, 스레드는 OS 레벨에서 관리하므로, `yield` 호출시 OS 레벨에서 스레드를 멈추고 다른 스레드가 실행된다.
 * - 코루틴 == 비선점형, 스레드 == 선점형
 */
fun main() {

}