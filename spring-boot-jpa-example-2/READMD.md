# Spring Boot + JPA 예제 2
> 본 학습 테스트는 [김영한님의 스프링 부트 + JPA 활용 2편](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-JPA-API%EA%B0%9C%EB%B0%9C-%EC%84%B1%EB%8A%A5%EC%B5%9C%EC%A0%81%ED%99%94)을 바탕으로 진행된 자료입니다.

<br>

# 목차

<br>

<br>

# API 개발

<br>

## 계층간의 역할을 분리하고 DTO를 활용하여 계층간의 통신을 하자.
* 각 계층간의 역할에 따라 객체를 분리시키는 것이 좋다. -> 계층간의 통신은 가능한 DTO로 하자.
  * 계층간의 역할을 분리하지않고, 통신하는데 DTO를 사용하지 않으면 발생하는 문제
    * 엔티티에 표현 계층을 위한 로직이 추가되어야한다.. (후..)
    * 각 API 요청별 엔티티의 어떤 값까지 사용하는지 파악하기 어렵다 (ex. 어떤 요청엔 name이 null이 아닌데, 어떤 요청엔 null일 수도..)
    * 기본적으로 엔티티의 모든 값이 노출되게된다. (Response에 엔티티를 그대로 사용한다면)
    * Response 스펙에 따라 엔티티에 로직이 추가될 수 있다. (@JsonIgnore, 혹은 별도의 뷰 로직 등등)
    * 실무에서는 같은 엔티티에 대해 API가 용도에 따라 다양하게 만들어지는데, 한 엔티티에 각각의 API를 위한 표현계층 응답 로직을 담기 어렵다.
    * 엔티티가 변경되면 API 스펙도 변경되게된다. (큰 문제..)
    * 컬렉션을 직접 반환하면 향후 API 스펙을 변경하기 어렵다. (별도의 Result 클래스 생성으로 해결해야한다.)
  * 결론: 가능하면 계층간의 통신은 DTO를 사용하는 것이좋다. 또한, API의 요청과 응답도 DTO를 사용하자.
* 응답 DTO는 리스트로 바로 반환하면 유연성이 떨어진다.
  * 아래와 같이 한차례 감싸서 안에 리스트를 반환하도록 하는 것이 추후 변경에 대한 유지보수에 편한다. (실무에선 특히 더더욱 더!)

```java
@Data
@AllArgsConstructor
static class Result<T> {
    private int count;
    private T data; // 리스트 혹은 특정 DTO.
}
```

<br>

## CQS
* CQS
  * Command과 Query를 철저히 분리시키는 것이 좋다.
  * 유지보수성에 도움이 많이 되기 때문.
  
<br>


